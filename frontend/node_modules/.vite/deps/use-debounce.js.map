{
  "version": 3,
  "sources": ["../../use-debounce/src/useDebouncedCallback.ts", "../../use-debounce/src/useDebounce.ts", "../../use-debounce/src/useThrottledCallback.ts"],
  "sourcesContent": ["import { useRef, useEffect, useMemo } from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n}\n\nexport interface ControlFunctions {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => void;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function `debounced.callback` return the result of the last func invocation.\n * Note, that if there are no previous invocations it's mean you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>> extends ControlFunctions {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<T extends (...args: any) => ReturnType<T>>(\n  func: T,\n  wait?: number,\n  options?: Options\n): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n\n  useEffect(() => {\n    funcRef.current = func;\n  }, [func]);\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && typeof window !== 'undefined';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const maxing = 'maxWait' in options;\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF ? requestAnimationFrame(pendingFunc) : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      if (timerId.current) {\n        useRAF ? cancelAnimationFrame(timerId.current) : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current = lastCallTime.current = lastThis.current = timerId.current = null;\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [leading, maxing, wait, maxWait, trailing, useRAF]);\n\n  return debounced;\n}\n", "import { useCallback, useRef, useState, Dispatch } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nfunction adjustFunctionValueOfSetState<T>(value: T): T | (() => T) {\n  return typeof value === 'function' ? () => value : value;\n}\n\nfunction useStateIgnoreCallback<T>(initialState: T): [T, Dispatch<T>] {\n  const [state, setState] = useState(adjustFunctionValueOfSetState(initialState));\n  const setStateIgnoreCallback = useCallback((value: T) => setState(adjustFunctionValueOfSetState(value)), []);\n  return [state, setStateIgnoreCallback];\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: { maxWait?: number; leading?: boolean; trailing?: boolean; equalityFn?: (left: T, right: T) => boolean }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const [state, dispatch] = useStateIgnoreCallback(value);\n  const debounced = useDebouncedCallback(useCallback((value: T) => dispatch(value), [dispatch]), delay, options);\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  return [state, debounced];\n}\n", "import useDebouncedCallback, { CallOptions, DebouncedState } from './useDebouncedCallback';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame).\n *\n * The throttled function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the throttled function.\n *\n * Subsequent calls to the throttled function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * const scrollHandler = useThrottledCallback(updatePosition, 100)\n * window.addEventListener('scroll', scrollHandler)\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const { callback } = useThrottledCallback(renewToken, 300000, { 'trailing': false })\n * <button onClick={callback}>click</button>\n *\n * // Cancel the trailing throttled invocation.\n * window.addEventListener('popstate', throttled.cancel);\n */\nexport default function useThrottledCallback<T extends (...args: any) => ReturnType<T>>(\n  func: T,\n  wait: number,\n  { leading = true, trailing = true }: CallOptions = {}\n): DebouncedState<T> {\n  return useDebouncedCallback(func, wait, {\n    maxWait: wait,\n    leading,\n    trailing,\n  });\n}\n"],
  "mappings": "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",
  "names": ["useDebouncedCallback", "func", "wait", "options", "lastCallTime", "useRef", "lastInvokeTime", "timerId", "lastArgs", "lastThis", "result", "funcRef", "mounted", "useEffect", "current", "useRAF", "window", "TypeError", "leading", "trailing", "maxing", "maxWait", "Math", "max", "debounced", "useMemo", "invokeFunc", "time", "args", "thisArg", "apply", "startTimer", "pendingFunc", "cancelAnimationFrame", "requestAnimationFrame", "setTimeout", "shouldInvoke", "timeSinceLastCall", "trailingEdge", "timerExpired", "Date", "now", "timeWaiting", "remainingWait", "min", "isInvoking", "slice", "call", "arguments", "_this", "cancel", "clearTimeout", "isPending", "flush", "valueEquality", "left", "right", "adjustFunctionValueOfSetState", "value", "useDebounce", "delay", "f", "setState", "eq", "equalityFn", "_useStateIgnoreCallba", "useState", "_useState", "useCallback", "state", "dispatch", "previousValue", "useThrottledCallback", "_temp", "_ref", "_ref$trailing", "_ref$leading"]
}
